require "http/client"
require "json"
require "yaml"
require "digest/sha256"

module Shards
  # Represents a single vulnerability found by OSV.
  struct Vulnerability
    getter id : String                       # e.g., "GHSA-xxxx-yyyy" or "CVE-2024-1234"
    getter summary : String                  # Short human-readable summary
    getter details : String                  # Full description
    getter severity : Severity               # Derived severity level
    getter cvss_score : Float64?             # CVSS score if available
    getter affected_versions : Array(String) # Affected version ranges as strings
    getter references : Array(String)        # URLs to advisories
    getter aliases : Array(String)           # Alternate IDs (CVE <-> GHSA)
    getter published : Time?                 # Date published
    getter modified : Time?                  # Date last modified

    def initialize(@id, @summary, @details, @severity, @cvss_score,
                   @affected_versions, @references, @aliases,
                   @published, @modified)
    end
  end

  # Severity levels with ordering support.
  enum Severity
    Unknown # No severity info
    Low
    Medium
    High
    Critical

    def self.parse(str : String) : Severity
      case str.downcase
      when "low"      then Low
      when "medium"   then Medium
      when "high"     then High
      when "critical" then Critical
      else                 Unknown
      end
    end

    # Returns true if this severity is at or above the given threshold.
    def at_or_above?(threshold : Severity) : Bool
      self.value >= threshold.value
    end
  end

  # Holds the scan result for a single package.
  struct PackageScanResult
    getter package : Package
    getter purl : String?
    getter vulnerabilities : Array(Vulnerability)

    def initialize(@package, @purl, @vulnerabilities = [] of Vulnerability)
    end

    def vulnerable? : Bool
      !vulnerabilities.empty?
    end
  end

  # Ignore rule loaded from .shards-audit-ignore or --ignore flag.
  struct IgnoreRule
    getter id : String
    getter reason : String?
    getter expires : Time?

    def initialize(@id, @reason = nil, @expires = nil)
    end

    def expired? : Bool
      if exp = @expires
        Time.utc > exp
      else
        false
      end
    end

    def active? : Bool
      !expired?
    end
  end

  class VulnerabilityScanner
    OSV_BATCH_URL = "https://api.osv.dev/v1/querybatch"
    OSV_QUERY_URL = "https://api.osv.dev/v1/query"
    CACHE_DIR     = ".shards/audit/cache"
    CACHE_TTL     = 1.hour # Default TTL for cached responses

    getter results : Array(PackageScanResult)

    @cache_dir : String
    @offline : Bool

    def initialize(@path : String, @offline : Bool = false)
      @cache_dir = File.join(@path, CACHE_DIR)
      @results = [] of PackageScanResult
    end

    # Main entry point: scans all packages for vulnerabilities.
    # Returns an array of PackageScanResult, one per package.
    def scan(packages : Array(Package)) : Array(PackageScanResult)
      # Step 1: Build purl-to-package mapping
      purl_map = {} of String => Package
      no_purl_packages = [] of Package

      packages.each do |pkg|
        if purl = PurlGenerator.generate(pkg)
          purl_map[purl] = pkg
        else
          no_purl_packages << pkg
        end
      end

      # Step 2: Query OSV (batch) for all purls
      vuln_map = query_batch(purl_map.keys)

      # Step 3: Build results
      @results = [] of PackageScanResult

      purl_map.each do |purl, pkg|
        vulns = vuln_map[purl]? || [] of Vulnerability
        @results << PackageScanResult.new(pkg, purl, vulns)
      end

      # Path dependencies get empty results
      no_purl_packages.each do |pkg|
        @results << PackageScanResult.new(pkg, nil, [] of Vulnerability)
      end

      @results.sort_by!(&.package.name)
    end

    # Query OSV batch endpoint with an array of purls.
    # Returns a mapping of purl -> Array(Vulnerability).
    private def query_batch(purls : Array(String)) : Hash(String, Array(Vulnerability))
      result = {} of String => Array(Vulnerability)
      return result if purls.empty?

      # Check cache first, collect uncached purls
      uncached_purls = [] of String

      purls.each do |purl|
        if cached = read_cache(purl)
          result[purl] = cached
        elsif @offline
          Log.debug { "No cached data for #{purl} (offline mode)" }
          result[purl] = [] of Vulnerability
        else
          uncached_purls << purl
        end
      end

      return result if uncached_purls.empty?

      # Build the batch query body
      # OSV batch format:
      # { "queries": [ { "package": { "purl": "pkg:..." } }, ... ] }
      body = JSON.build do |json|
        json.object do
          json.field "queries" do
            json.array do
              uncached_purls.each do |purl|
                json.object do
                  json.field "package" do
                    json.object do
                      json.field "purl", purl
                    end
                  end
                end
              end
            end
          end
        end
      end

      # Execute HTTP request
      Log.info { "Querying OSV for #{uncached_purls.size} package(s)..." }
      response_body = http_post(OSV_BATCH_URL, body)

      # Parse batch response
      # OSV batch response format:
      # { "results": [ { "vulns": [ {...}, ... ] }, ... ] }
      parsed = JSON.parse(response_body)
      batch_results = parsed["results"].as_a

      uncached_purls.each_with_index do |purl, idx|
        vulns = [] of Vulnerability

        if idx < batch_results.size
          entry = batch_results[idx]
          if vuln_array = entry["vulns"]?.try(&.as_a)
            vuln_array.each do |v|
              vulns << parse_vulnerability(v)
            end
          end
        end

        result[purl] = vulns
        write_cache(purl, vulns)
      end

      result
    end

    # Parses a single OSV vulnerability JSON object into a Vulnerability struct.
    private def parse_vulnerability(json : JSON::Any) : Vulnerability
      id = json["id"].as_s
      summary = json["summary"]?.try(&.as_s) || ""
      details = json["details"]?.try(&.as_s) || ""

      # Extract severity from database_specific or severity array
      severity = Severity::Unknown
      cvss_score = nil

      if severity_arr = json["severity"]?.try(&.as_a)
        severity_arr.each do |sev|
          if sev_type = sev["type"]?.try(&.as_s)
            case sev_type
            when "CVSS_V3"
              if score = parse_cvss_score(sev["score"]?.try(&.as_s))
                cvss_score = score
                severity = cvss_to_severity(score)
              end
            end
          end
        end
      end

      # Fallback: check database_specific.severity
      if severity.unknown?
        if db_sev = json["database_specific"]?.try(&.["severity"]?.try(&.as_s))
          severity = Severity.parse(db_sev)
        end
      end

      # Affected version ranges
      affected_versions = [] of String
      if affected = json["affected"]?.try(&.as_a)
        affected.each do |aff|
          if ranges = aff["ranges"]?.try(&.as_a)
            ranges.each do |range|
              events = range["events"]?.try(&.as_a) || next
              events.each do |event|
                if intro = event["introduced"]?.try(&.as_s)
                  affected_versions << "introduced: #{intro}"
                end
                if fixed = event["fixed"]?.try(&.as_s)
                  affected_versions << "fixed: #{fixed}"
                end
              end
            end
          end
        end
      end

      # References
      references = [] of String
      if refs = json["references"]?.try(&.as_a)
        refs.each do |ref|
          if url = ref["url"]?.try(&.as_s)
            references << url
          end
        end
      end

      # Aliases
      aliases = [] of String
      if alias_arr = json["aliases"]?.try(&.as_a)
        alias_arr.each do |a|
          aliases << a.as_s
        end
      end

      # Timestamps
      published = json["published"]?.try { |t| Time.parse_rfc3339(t.as_s) rescue nil }
      modified = json["modified"]?.try { |t| Time.parse_rfc3339(t.as_s) rescue nil }

      Vulnerability.new(
        id: id,
        summary: summary,
        details: details,
        severity: severity,
        cvss_score: cvss_score,
        affected_versions: affected_versions,
        references: references,
        aliases: aliases,
        published: published,
        modified: modified
      )
    end

    # Parses a CVSS v3 vector string and extracts the numeric score.
    # OSV often provides the vector string; we compute the score.
    # Simplified: use the base score if provided directly.
    private def parse_cvss_score(vector : String?) : Float64?
      return nil unless vector
      # If the vector is just a number, parse it
      vector.to_f64? || nil
    end

    # Maps a numeric CVSS score to a severity level.
    private def cvss_to_severity(score : Float64) : Severity
      case score
      when 0.0..3.9  then Severity::Low
      when 4.0..6.9  then Severity::Medium
      when 7.0..8.9  then Severity::High
      when 9.0..10.0 then Severity::Critical
      else                Severity::Unknown
      end
    end

    # HTTP POST helper with error handling and timeouts.
    private def http_post(url : String, body : String) : String
      uri = URI.parse(url)
      client = HTTP::Client.new(uri)
      client.connect_timeout = 10.seconds
      client.read_timeout = 30.seconds

      headers = HTTP::Headers{
        "Content-Type" => "application/json",
        "User-Agent"   => "shards-alpha/#{VERSION}",
      }

      response = client.post(uri.request_target, headers: headers, body: body)

      unless response.success?
        raise Error.new("OSV API request failed with status #{response.status_code}: #{response.body[0..200]}")
      end

      response.body
    ensure
      client.try(&.close)
    end

    # Force refresh all cached data.
    def update_cache(packages : Array(Package))
      clear_cache
      scan(packages)
    end

    # --- Cache methods ---

    private def cache_key(purl : String) : String
      # Use a hash of the purl as the filename to avoid filesystem issues
      Digest::SHA256.hexdigest(purl)
    end

    private def cache_path(purl : String) : String
      File.join(@cache_dir, "#{cache_key(purl)}.json")
    end

    private def read_cache(purl : String) : Array(Vulnerability)?
      path = cache_path(purl)
      return nil unless File.exists?(path)

      # Check TTL
      mtime = File.info(path).modification_time
      return nil if (Time.utc - mtime) > CACHE_TTL

      json = JSON.parse(File.read(path))
      vulns = [] of Vulnerability
      json.as_a.each do |v|
        vulns << parse_cached_vulnerability(v)
      end
      vulns
    rescue
      nil
    end

    private def write_cache(purl : String, vulns : Array(Vulnerability))
      Dir.mkdir_p(@cache_dir)
      path = cache_path(purl)

      data = JSON.build do |json|
        json.array do
          vulns.each do |v|
            json.object do
              json.field "id", v.id
              json.field "summary", v.summary
              json.field "details", v.details
              json.field "severity", v.severity.to_s.downcase
              json.field "cvss_score", v.cvss_score
              json.field "affected_versions" do
                json.array { v.affected_versions.each { |av| json.string av } }
              end
              json.field "references" do
                json.array { v.references.each { |r| json.string r } }
              end
              json.field "aliases" do
                json.array { v.aliases.each { |a| json.string a } }
              end
              json.field "published", v.published.try(&.to_rfc3339)
              json.field "modified", v.modified.try(&.to_rfc3339)
            end
          end
        end
      end

      File.write(path, data)
    end

    private def parse_cached_vulnerability(json : JSON::Any) : Vulnerability
      Vulnerability.new(
        id: json["id"].as_s,
        summary: json["summary"].as_s,
        details: json["details"].as_s,
        severity: Severity.parse(json["severity"].as_s),
        cvss_score: json["cvss_score"]?.try(&.as_f?),
        affected_versions: json["affected_versions"].as_a.map(&.as_s),
        references: json["references"].as_a.map(&.as_s),
        aliases: json["aliases"].as_a.map(&.as_s),
        published: json["published"]?.try { |t| t.as_s?.try { |s| Time.parse_rfc3339(s) rescue nil } },
        modified: json["modified"]?.try { |t| t.as_s?.try { |s| Time.parse_rfc3339(s) rescue nil } }
      )
    end

    private def clear_cache
      Shards::Helpers.rm_rf(@cache_dir) if Dir.exists?(@cache_dir)
    end

    # --- Ignore file parsing ---

    def self.load_ignore_rules(path : String) : Array(IgnoreRule)
      rules = [] of IgnoreRule
      return rules unless File.exists?(path)

      yaml = YAML.parse(File.read(path))
      if ignores = yaml["ignores"]?.try(&.as_a)
        ignores.each do |entry|
          id = entry["id"].as_s
          reason = entry["reason"]?.try(&.as_s)
          expires = entry["expires"]?.try { |e| Time.parse(e.as_s, "%Y-%m-%d", Time::Location::UTC) rescue nil }
          rules << IgnoreRule.new(id, reason, expires)
        end
      end

      rules
    end
  end
end
